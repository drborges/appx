// AUTO GENERATED BY appx-cli - DO NOT EDIT

package generated

import (
	"appengine"
	"appengine/datastore"
	"github.com/drborges/appx"
	"github.com/drborges/rivers"
)

func FromUser(context appengine.Context) *UserAppxRepository {
	return &UserAppxRepository{
		db: appx.NewDatastore(context),
	}
}

type UserAppxRepository struct {
	db *appx.Datastore
}

func (repo *UserAppxRepository) New() *UserAppxModel {
	return &UserAppxModel{
		db: repo.db,
	}
}

func (repo *UserAppxRepository) GetByKey(key *datastore.Key) (*UserAppxModel, error) {
	item := &User{}
	item.SetKey(key)
	return item, repo.db.Load(item)
}

func (repo *UserAppxRepository) GetByEncodedKey(key string) (*UserAppxModel, error) {
	item := &User{}
	if err := item.SetEncodedKey(key); err != nil {
		return nil, err
	}
	return item, repo.db.Load(item)
}




func (repo *UserAppxRepository) GetByAge(value int) (*UserAppxModel, error) {
	item := &User{
		Age: value,
	}
	return item, repo.db.Load(item)
}

func (repo *UserAppxRepository) GetByEmail(value string) (*UserAppxModel, error) {
	item := &User{
		Email: value,
	}
	return item, repo.db.Load(item)
}

func (repo *UserAppxRepository) GetByName(value string) (*UserAppxModel, error) {
	item := &User{
		Name: value,
	}
	return item, repo.db.Load(item)
}

func (repo *UserAppxRepository) GetByToken(value string) (*UserAppxModel, error) {
	item := &User{
		Token: value,
	}
	return item, repo.db.Load(item)
}



func (repo *UserAppxRepository) FindWhereAge(op string, value int) *UserQueryRunner {
	q := datastore.NewQuery(new(User).KeySpec().Kind).Filter("Age" + op, value)
	return &UserQueryRunner{
		db: repo.db,
		q:  q,
	}
}

func (repo *UserAppxRepository) FindWhereEmail(op string, value string) *UserQueryRunner {
	q := datastore.NewQuery(new(User).KeySpec().Kind).Filter("Email" + op, value)
	return &UserQueryRunner{
		db: repo.db,
		q:  q,
	}
}

func (repo *UserAppxRepository) FindWhereName(op string, value string) *UserQueryRunner {
	q := datastore.NewQuery(new(User).KeySpec().Kind).Filter("Name" + op, value)
	return &UserQueryRunner{
		db: repo.db,
		q:  q,
	}
}

func (repo *UserAppxRepository) FindWhereToken(op string, value string) *UserQueryRunner {
	q := datastore.NewQuery(new(User).KeySpec().Kind).Filter("Token" + op, value)
	return &UserQueryRunner{
		db: repo.db,
		q:  q,
	}
}












func (repo *UserAppxRepository) FindWhere(filter string, value interface{}) *UserQueryRunner {
	q := datastore.NewQuery(new(User).KeySpec().Kind).Filter(filter, value)
	return &UserQueryRunner{
		db: repo.db,
		q:  q,
	}
}

func (repo *UserAppxRepository) FindWhereAncestorIs(ancestor appx.Entity) *UserQueryRunner {
	q := datastore.NewQuery(new(User).KeySpec().Kind).Ancestor(ancestor.Key())
	return &UserQueryRunner{
		db: repo.db,
		q:  q,
	}
}

func (repo *UserAppxRepository) FindBy(q *datastore.Query) *UserQueryRunner {
	return &UserQueryRunner{
		db: repo.db,
		q:  q,
	}
}


func (repo *UserAppxRepository) FindByAge(value int) *UserQueryRunner {
	q := datastore.NewQuery(new(User).KeySpec().Kind).Filter("Age=", value)
	return &UserQueryRunner{
		db: repo.db,
		q:  q,
	}
}

func (repo *UserAppxRepository) FindByEmail(value string) *UserQueryRunner {
	q := datastore.NewQuery(new(User).KeySpec().Kind).Filter("Email=", value)
	return &UserQueryRunner{
		db: repo.db,
		q:  q,
	}
}

func (repo *UserAppxRepository) FindByName(value string) *UserQueryRunner {
	q := datastore.NewQuery(new(User).KeySpec().Kind).Filter("Name=", value)
	return &UserQueryRunner{
		db: repo.db,
		q:  q,
	}
}

func (repo *UserAppxRepository) FindByToken(value string) *UserQueryRunner {
	q := datastore.NewQuery(new(User).KeySpec().Kind).Filter("Token=", value)
	return &UserQueryRunner{
		db: repo.db,
		q:  q,
	}
}


type UserQueryRunner struct {
	db *appx.Datastore
	q  *datastore.Query
}

func (runner *UserQueryRunner) Select(fields ...string) *UserQueryRunner {
	runner.q = runner.q.Project(fields...)
	return runner
}

func (runner *UserQueryRunner) Distinct() *UserQueryRunner {
	runner.q = runner.q.Distinct()
	return runner
}

func (runner *UserQueryRunner) Limit(limit int) *UserQueryRunner {
	runner.q = runner.q.Limit(limit)
	return runner
}

func (runner *UserQueryRunner) KeysOnly() *UserQueryRunner {
	runner.q = runner.q.KeysOnly()
	return runner
}


func (runner *UserQueryRunner) OrderByAgeAsc() *UserQueryRunner {
	runner.q = runner.q.Order("Age")
	return runner
}

func (runner *UserQueryRunner) OrderByEmailAsc() *UserQueryRunner {
	runner.q = runner.q.Order("Email")
	return runner
}

func (runner *UserQueryRunner) OrderByNameAsc() *UserQueryRunner {
	runner.q = runner.q.Order("Name")
	return runner
}

func (runner *UserQueryRunner) OrderByTokenAsc() *UserQueryRunner {
	runner.q = runner.q.Order("Token")
	return runner
}



func (runner *UserQueryRunner) OrderByAgeDesc() *UserQueryRunner {
	runner.q = runner.q.Order("-Age")
	return runner
}

func (runner *UserQueryRunner) OrderByEmailDesc() *UserQueryRunner {
	runner.q = runner.q.Order("-Email")
	return runner
}

func (runner *UserQueryRunner) OrderByNameDesc() *UserQueryRunner {
	runner.q = runner.q.Order("-Name")
	return runner
}

func (runner *UserQueryRunner) OrderByTokenDesc() *UserQueryRunner {
	runner.q = runner.q.Order("-Token")
	return runner
}


func (runner *UserQueryRunner) Stream() *rivers.Stage {
	return runner.db.Query(runner.q).StreamOf(User{})
}

func (runner *UserQueryRunner) Count() (int, error) {
	return runner.db.Query(runner.q).Count()
}

func (runner *UserQueryRunner) All() ([]*UserAppxModel, error) {
	items := []*UserAppxModel{}
	return items, runner.db.Query(runner.q).Results(items)
}

func (runner *UserQueryRunner) First() (*UserAppxModel, error) {
	item := &UserAppxModel{}
	return item, runner.db.Query(runner.q.Limit(1)).Result(item)
}

func (runner *UserQueryRunner) PagesIterator() appx.Iterator {
	return runner.db.Query(runner.q).PagesIterator()
}

func (runner *UserQueryRunner) ItemsIterator() appx.Iterator {
	return runner.db.Query(runner.q).ItemsIterator()
}

func (runner *UserQueryRunner) StartFrom(cursor string) *UserQueryRunner {
	q := runner.db.Query(runner.q).StartFrom(cursor)
	return &UserQueryRunner{
		db: runner.db,
		q:  q,
	}
}